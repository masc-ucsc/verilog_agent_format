
**Project ToDo List: Verilog Formatting Tool**

**Objective:**
Develop an Fine-tuned LLM that takes a valid Verilog program and generates an equivalent Verilog program that is more readable and maintainable. The tool should improve formatting, indentation, and make minor code adjustments while ensuring the transformed code is functionally equivalent to the original.

It can include a set of scripts like verible formatting to simplify the LLM task.

---

### **1. Setup and Familiarization**

**a. Install and Compile LiveHD**
- Clone the LiveHD repository from its official source.
- Follow the installation instructions to compile LiveHD on your machine.
- Ensure all dependencies are met and resolve any build issues.

**b. Verify LiveHD Installation**
- Run a simple test to ensure LiveHD is working:
  ```bash
  ./bazel-bin/main/lgshell "inou.yosys.tolg files:inou/yosys/tests/trivial.v |> inou.cgen.verilog odir:tmp"
  ```
- Check that `tmp/trivial.v` is generated.

**c. Understand LiveHD Workflow**
- Familiarize yourself with the commands and generate multiple Verilog outputs.

---

### **2. Initial Verilog Processing**

**a. Analyze Generated Verilog**
- Compare `tmp/trivial.v` with `inou/yosys/tests/trivial.v`.
- Note differences in formatting and structure.
- Document any discrepancies and understand why they occur.

**b. Explore LiveHD Settings**
- Investigate if LiveHD has options to control output formatting.
- Experiment with settings to make the generated Verilog closer to the original.

---

### **3. Integrate Verible for Code Formatting**

**a. Install Verible**
- Clone the Verible repository:
  ```bash
  git clone https://github.com/chipsalliance/verible.git
  ```
- Follow the build instructions to install Verible tools on your system.

**b. Format Verilog with Verible**
- Use Verible formatter on the Verilog files generated by LiveHD:
  ```bash
  verible-verilog-format tmp/trivial.v > tmp/trivial_formatted.v
  ```
- Compare the formatted code with the original and assess improvements.

**c. Configure Verible Formatting Styles**
- Adjust Verible settings to match desired coding style guidelines.
- Document the configuration used for consistency.

---

### **4. Prepare Dataset for LLM**

**a. Collect Verilog Files**
- Use LiveHD to process various Verilog files and generate corresponding outputs.
- Ensure a diverse set of Verilog code examples (different modules, styles, complexities).

**b. Create a Database**
- Organize the original and LiveHD-generated Verilog files systematically.
- Maintain metadata for each file (e.g., source, purpose, special features).

**c. Preprocess Data**
- Use Verible to format all collected Verilog files uniformly.
- Ensure consistency across the dataset to aid in LLM training and evaluation.

---

### **5. LLM Integration**

**a. Choose an Appropriate LLM**
- Decide on the language model to use (e.g., https://github.com/QwenLM/Qwen2.5-Coder)
- Ensure the model supports code processing and generation.

**b. Define Transformation Goals**
- Clearly outline what improvements the LLM should make (e.g., renaming signals for clarity, restructuring code blocks).
- Prepare guidelines or examples for the desired output.

**c. Develop Prompts and Instructions**
- Craft effective prompts to guide the LLM in transforming the code.
- Include specific instructions and examples within the prompts if necessary.

**d. Test LLM Outputs**
- Run initial tests with the LLM on sample Verilog code.
- Evaluate the transformed code for correctness and readability.


**e. The fine tune will be in llmhdl.cse.ucsc.edu
---

### **6. Equivalence Checking with Yosys**

**a. Install Yosys**
- Install Yosys for hardware description language synthesis and verification:
  ```bash
  sudo apt-get install yosys
  ```
- Verify the installation by running a simple command.

**b. Automate Equivalence Checks**
- Write scripts to compare the original and transformed Verilog files:
  ```bash
  yosys -p "read_verilog original.v; hierarchy -top top; proc; opt; memory; flatten; write_json original.json"
  yosys -p "read_verilog transformed.v; hierarchy -top top; proc; opt; memory; flatten; write_json transformed.json"
  ```
- Use Yosys or other tools to compare the generated netlists or intermediate representations.

**c. Handle Discrepancies**
- If differences are found, analyze and understand why.
- Ensure that any transformations do not alter the functionality.

---

### **7. Refinement and Iteration**

**a. Feedback Loop**
- Based on equivalence checks and code reviews, refine the prompts and transformation rules.
- Iterate the process to improve the quality of the transformed code.

**b. Performance Optimization**
- Assess the processing time and resource usage.
- Optimize scripts and processes for efficiency.

---

### **8. Documentation**

**a. Document the Process**
- Write detailed documentation for each step taken.
- Include installation guides, usage instructions, and troubleshooting tips.

**b. Code Comments**
- Ensure all scripts and code snippets are well-commented.
- Explain the purpose and functionality of code sections.

---

### **9. Reporting and Presentation**

**a. Prepare a Project Report**
- Summarize the objectives, methodology, results, and conclusions.
- Include examples of code transformations and equivalence check outcomes.

**b. Develop Presentation Materials**
- Create slides or posters to present the project findings.
- Highlight key achievements and lessons learned.

---

**By following this ToDo list, you'll systematically build a tool that enhances Verilog code readability while ensuring functional equivalence. Good luck with your project!**

